<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Breach | Master Build</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');
        body { margin: 0; overflow: hidden; font-family: 'Orbitron', sans-serif; background: #000; color: #00ffcc; }
        
        /* HUD & UI */
        #ui { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-around; pointer-events: none; z-index: 5; text-shadow: 0 0 10px #00ffcc; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; border: 2px solid #00ffcc; transform: translate(-50%, -50%); border-radius: 50%; z-index: 4; }
        #ammoHUD { position: absolute; bottom: 20px; right: 30px; font-size: 24px; }
        #playerHealthHUD { position: absolute; bottom: 20px; left: 20px; font-size: 24px; transition: 0.3s; }
        
        /* OVERLAYS */
        #overlay { position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 20; background: radial-gradient(circle, rgba(10, 20, 30, 0.9) 0%, #000 100%); }
        #scopeOverlay { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: radial-gradient(circle, transparent 25%, #000 35%, #000 100%); display: none; z-index: 10; pointer-events: none; }
        #timeSlowOverlay { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(255, 0, 255, 0.15); display: none; z-index: 8; pointer-events: none; }
        #damageFlash { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(255, 0, 0, 0.3); display: none; pointer-events: none; z-index: 15; }
        #reloadingText { position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); color: #ffff00; display: none; font-size: 20px; }

        .golden-mode { color: #ffcc00 !important; text-shadow: 0 0 15px #ffcc00 !important; animation: goldGlow 2s infinite; }
        @keyframes goldGlow { 0% { filter: brightness(1); } 50% { filter: brightness(1.3); } 100% { filter: brightness(1); } }
        
        .shake-camera { animation: shake 0.2s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -2px); } 100% { transform: translate(1px, 1px); } }

        .btn { padding: 15px 60px; background: transparent; color: #00ffcc; border: 2px solid #00ffcc; cursor: pointer; font-family: 'Orbitron'; font-size: 22px; }
    </style>
</head>
<body>
    <div id="ui">
        <div>KILLS: <span id="kills">0</span> <span id="streakUI"></span></div>
        <div id="weaponHUD">WEAPON: <span id="weaponName">Pistol</span></div>
        <div>[Q] AIM | [R] RELOAD | [SPACE] CHRONOS</div>
    </div>

    <div id="playerHealthHUD">HEALTH: <span id="hpValue">100</span></div>
    <div id="ammoHUD">AMMO: <span id="currentAmmo">12</span> / <span id="maxAmmo">12</span></div>
    <div id="reloadingText">RELOADING...</div>
    <div id="scopeOverlay"></div>
    <div id="timeSlowOverlay"></div>
    <div id="damageFlash"></div>
    <div id="crosshair"></div>

    <div id="overlay">
        <div style="text-align:center;">
            <h1 style="font-size: 60px; border: 4px solid #00ffcc; padding: 10px 30px;">NB</h1>
            <button class="btn" onclick="requestStart()">PLAY</button>
        </div>
    </div>

    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

        // --- CORE STATE ---
        let kills = 0, currentStreak = 0, playerHP = 100, isReloading = false;
        let isAiming = false, timeScale = 1.0, isTimeSlowed = false, hasGoldenGun = false;
        let weaponIdx = 1; // Start with Pistol

        const weapons = [
            { name: "Neon AR", hasScope: true, color: 0x00ffff, adsZoom: 25, damage: 25, fireRate: 300, magSize: 30, currentMag: 30 },
            { name: "Pistol", hasScope: false, color: 0x00ffcc, adsZoom: 45, damage: 40, fireRate: 500, magSize: 12, currentMag: 12 }
        ];

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const controls = new PointerLockControls(camera, document.body);
        const weaponGroup = new THREE.Group();
        camera.add(weaponGroup);
        scene.add(camera);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // --- ENEMY & PICKUP SYSTEMS ---
        const enemies = [];
        const healthPickups = [];

        function spawnBot(isBoss = false) {
            const botGroup = new THREE.Group();
            const size = isBoss ? 3 : 1;
            const color = isBoss ? 0xff6600 : 0xff0055;
            const body = new THREE.Mesh(new THREE.BoxGeometry(size, size*2, size), new THREE.MeshStandardMaterial({color: color, wireframe: true}));
            botGroup.add(body);
            botGroup.position.set(Math.random()*40-20, size, Math.random()*40-20);
            scene.add(botGroup);
            enemies.push({ mesh: botGroup, hp: isBoss ? 500 : 100, isBoss, lastAttack: 0, speed: isBoss ? 1.5 : 3.5 });
        }

        function spawnHealth() {
            const pickup = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({color: 0x00ff00}));
            pickup.position.set(Math.random()*30-15, 0.5, Math.random()*30-15);
            scene.add(pickup);
            healthPickups.push(pickup);
        }

        for(let i=0; i<4; i++) spawnBot();
        spawnHealth();

        // --- WEAPON MECHANICS ---
        function updateWeaponModel() {
            weaponGroup.clear();
            const w = weapons[weaponIdx];
            const color = hasGoldenGun ? 0xffcc00 : w.color;
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 1), new THREE.MeshStandardMaterial({color: color, wireframe: !hasGoldenGun}));
            weaponGroup.add(body);
            if(w.hasScope) {
                const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3), new THREE.MeshStandardMaterial({color: 0xffffff}));
                scope.rotation.x = Math.PI/2; scope.position.y = 0.2;
                weaponGroup.add(scope);
            }
            weaponGroup.position.set(0.5, -0.4, -1);
            document.getElementById('weaponName').innerText = w.name;
            updateAmmoUI();
        }

        function updateAmmoUI() {
            const w = weapons[weaponIdx];
            document.getElementById('currentAmmo').innerText = w.currentMag;
            document.getElementById('maxAmmo').innerText = w.magSize;
        }

        function reload() {
            const w = weapons[weaponIdx];
            if (isReloading || w.currentMag === w.magSize) return;
            isReloading = true;
            document.getElementById('reloadingText').style.display = 'block';
            weaponGroup.position.y = -1.5;
            setTimeout(() => {
                w.currentMag = w.magSize;
                updateAmmoUI();
                isReloading = false;
                document.getElementById('reloadingText').style.display = 'none';
                weaponGroup.position.y = -0.4;
            }, 1500);
        }

        // --- INPUTS ---
        window.addEventListener('mousedown', () => {
            if (!controls.isLocked || isReloading) return;
            const w = weapons[weaponIdx];
            if (w.currentMag <= 0) { reload(); return; }

            w.currentMag--;
            updateAmmoUI();
            weaponGroup.position.z += 0.2; // Recoil

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(enemies.map(e => e.mesh), true);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                const enemy = enemies.find(e => e.mesh === hit.object.parent || e.mesh === hit.object);
                let dmg = hasGoldenGun ? w.damage * 2 : w.damage;
                if ((hit.point.y - enemy.mesh.position.y) > 0.6) dmg *= 3; // Headshot

                enemy.hp -= dmg;
                if (enemy.hp <= 0) {
                    if(enemy.isBoss) { hasGoldenGun = true; updateWeaponModel(); document.getElementById('weaponHUD').classList.add('golden-mode'); }
                    scene.remove(enemy.mesh);
                    enemies.splice(enemies.indexOf(enemy), 1);
                    kills++; currentStreak++;
                    document.getElementById('kills').innerText = kills;
                    if(kills % 10 === 0) spawnBot(true);
                    spawnBot();
                }
            }
        });

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'q') { isAiming = true; document.getElementById('crosshair').style.opacity = '0'; }
            if (k === 'r') reload();
            if (k === '1') { weaponIdx = 0; updateWeaponModel(); }
            if (k === '2') { weaponIdx = 1; updateWeaponModel(); }
            if (e.code === 'Space' && currentStreak >= 10) {
                isTimeSlowed = true; timeScale = 0.2;
                document.getElementById('timeSlowOverlay').style.display = 'block';
                setTimeout(() => { isTimeSlowed = false; timeScale = 1.0; document.getElementById('timeSlowOverlay').style.display = 'none'; }, 5000);
            }
        });

        window.addEventListener('keyup', (e) => { if (e.key.toLowerCase() === 'q') { isAiming = false; document.getElementById('crosshair').style.opacity = '1'; } });

        window.requestStart = () => { controls.lock(); document.getElementById('overlay').style.display = 'none'; };

        // --- GAME LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if (!controls.isLocked) return;
            const dt = clock.getDelta() * timeScale;

            // ADS Logic
            const w = weapons[weaponIdx];
            const targetPos = isAiming ? new THREE.Vector3(0, -0.2, -0.4) : new THREE.Vector3(0.5, -0.4, -1);
            weaponGroup.position.lerp(targetPos, 0.2);
            camera.fov += ((isAiming ? w.adsZoom : 75) - camera.fov) * 0.2;
            camera.updateProjectionMatrix();

            const scopeUI = document.getElementById('scopeOverlay');
            if (w.hasScope && isAiming && camera.fov < (w.adsZoom + 5)) { scopeUI.style.display = 'block'; weaponGroup.visible = false; }
            else { scopeUI.style.display = 'none'; weaponGroup.visible = true; }

            // AI Brains
            enemies.forEach((bot, idx) => {
                const dist = bot.mesh.position.distanceTo(camera.position);
                const dir = new THREE.Vector3().subVectors(camera.position, bot.mesh.position).normalize();
                
                if (bot.hp < 20 && !bot.isBoss) { // Fear State
                    bot.mesh.lookAt(camera.position); bot.mesh.rotation.y += Math.PI;
                    bot.mesh.position.addScaledVector(dir, -bot.speed * 1.5 * dt);
                } else if (dist > 4) { // Chase
                    bot.mesh.lookAt(camera.position);
                    bot.mesh.position.addScaledVector(dir, bot.speed * dt);
                } else { // Attack
                    if (Date.now() - bot.lastAttack > 1000) {
                        playerHP -= bot.isBoss ? 30 : 10;
                        document.getElementById('hpValue').innerText = playerHP;
                        bot.lastAttack = Date.now();
                        if(playerHP <= 0) location.reload();
                    }
                }
            });

            // Health Pickups
            healthPickups.forEach((p, i) => {
                if(camera.position.distanceTo(p.position) < 1.5) {
                    playerHP = Math.min(100, playerHP + 40);
                    document.getElementById('hpValue').innerText = playerHP;
                    scene.remove(p); healthPickups.splice(i, 1);
                    setTimeout(spawnHealth, 10000);
                }
            });

            renderer.render(scene, camera);
        }
        updateWeaponModel();
        animate();
    </script>
</body>
</html>
